
# 设计目标

  这是一个基础的解析架构(Parser-Architecture)。

  前端有主要有两个相关功能：上传文件，然后触发后端解析功能,同时能够更新解析状态。

  其中，后端的解析时间大概为20s/file,而且内存占用率比较高（一些模型文件等），CPU密集型计算

  注意：这里前后端的解析是通过Thrift-RPC的。


# 变更历史

    ## version_0

        最初是从zhenqi那边接手过来的后端逻辑（应该也是abiao的后台逻辑）。大体设计如下：

        1) 前端upload文件，然后通过thrift接口call(json-interface)

        2) 后端thrift是一个threadServer,interface中接收到json_request,之后做了一个基本的

           format校验(尝试json_request_str能否decode成功),然后就起了一个解析子进程P1(multiprocess.Process) 同时返回res.

        3) 因为上面那个P1进程并没有join,因此，对于这个接口来说是一个异步的。P1进程是解析的耗时操作,

           每一步的解析结果都会写入DB,然后前端通过定时拉取数据库来同步状态。

        那这个设计有什么问题呢？
       
        答：没有并发控制。我在第一次做压力测试时，一下上传了200个文件，直接把服务器压挂了。
           
        然后我就想当然的说，那好办，搞个ThreadPoolServer。其实根本没解决问题。因为P1是异步的，
           
        一个线程接收到请求之后，立即fork了一个process进行异步处理,然后工作线程就收工，继续奔赴

        下一个战场了。所以线程池里面的线程数根本没有起到控制并发的作用。（这个我后面也会提到，就是

        我模糊的那个元问题。)
        
     ## version_1   
         
        然后我傻不愣登的想到一个神奇的方案。既然线程数控制不了异步P1，我就把P1的异步取消(添加join())

        这样的话，我不就能通过线程池大小来控制并发量了吗？

        是的，没错，肯定是这样的。

        然后，我就稍微勾划了一下方案，跟LongGe 和 huanjun去兜售，说要改，要这么改。

        但是，这里有个问题啊，你是爽了，前端呢？

        原来是异步接口，前端调用完之后，直接就返回。现在你要改成同步的，前端岂不是要被拖成狗？

        而且本来后面的流程就是异步的（往数据库里写）

        其实，我这么想的原因，还是因为那个元问题，我天真的:“非阻塞”<=>异步，“阻塞”<=>同步。

        所以，当我认为要取消 异步时，就等于 取消了 “非阻塞”。
       
        其实，在此之前，我跟LongGe聊的时候，LongGe还 

     ## version_2

        



# 反思

       1）从一开始的我的思考中就存在一个问题，就是我把(异步／同步),(阻塞／非阻塞)给混了。

        这个问题是要解决的一个
       




















 
